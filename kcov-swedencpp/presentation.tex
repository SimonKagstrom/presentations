\documentclass{beamer}


\usepackage[utf8]{inputenc}
\usepackage{pgfpages}
\setbeameroption{show notes}
\setbeameroption{show notes on second screen=left}

\usetheme{Warsaw}
\graphicspath{ {./images/}{../images/} }

\AtBeginSection[specialframe]
{
  \begin{frame}{Table of Contents}
   \tableofcontents[currentsection]
  \end{frame}
}

\title[Kcov - a single-step code coverage tool] %optional
{Kcov - a single-step code coverage tool}

%\subtitle{A short story}

\author{Simon Kågström}

\institute
{
  Net Insight\\
}

%\logo{\includegraphics[height=1.5cm]{lion-logo.png}}

\begin{document}

\begin{frame}
  \titlepage
  \note{My name is Simon Kågström and I work at Net Insight. Today I will present kcov, a code coverage collection and presentation tool. So let's get started!}
\end{frame}

\begin{frame}
  \frametitle{Motivation}
  \note<1->{
    \footnotesize
    I'll start with some motivation for the talk. Code coverage, as described by wikipedia, is the degree to which the source code of a program is executed when a particular test suite executes, measured in percentage.

    So let's say you're the developer of a particular piece of code, as shown on the slide. You run some tests on it, and collect code coverage to see how well your test suite actually works.
  }
  \note<2>{
    After code coverage collection, you will get a report which looks something like this. Red lines denote executable lines which have not been executed, green lines are executed lines. White lines is non-executable lines.

    Hmm... Hang on now, why is everything between line 128 and 143 marked as non-executable? Some of you might already have identified the code in question. This is the SSL/TLS bug known as ``goto fail''. Looking at line 127, you can see that the control flow will unconditionally jump to the fail label, so lines 128 to 143 are indeed unreachable.

    Stands out pretty clear from the coverage report don't you think? Modern compilers will also issue a warning on code like this.
    }
    
  \includegraphics<1>[height=8cm]{goto_fail_no_coverage}
  \includegraphics<2>[height=8cm]{goto_fail}
\end{frame}

\begin{frame}{Outline}
  \tableofcontents
  \note{This is the outline of the talk. I will start with a short discussion of problems and limitations with traditional tools, then introduce kcov and demonstrate some of the main features.

    I will then go into a bit of details about how kcov has been implemented, and give some lessons learned in the process.

  Finally, I will discuss some other features of kcov, which are perhaps a bit less relevant on a C++ workshop.}
\end{frame}

\section{Overview}
\subsection{Problems with traditional tools}
\begin{frame}[fragile]{Problems with traditional tools}
  \note{On UNIX, the traditional way of collecting code coverage has been to use gcov for collection, and lcov for HTML presentation, if desired. The process is a bit cumbersome, as can be seen in the example below. You first need a special --coverage option, which produces extra metadata files in the build directory. After running the program, you then get data for the actual execution in the build directory.

    After this, you need to run the presentation tool, like lcov, to get actual output. If the process crashes during execution, you will lose the coverage output altogether.

    % Mention clang

    Fortunately, using kcov does away with all these disadvantages, allowing collection without special compiler options, reporting without droppings and all done in a single step. Quite a sales pitch, don't you agree?}
  \begin{itemize}
  \item gcov + lcov is a multi-step process
  \item gcov leaves droppings after compilation/running
  \item A program which crashes will not generate coverage data
  \end{itemize}
  \begin{Example}
    \begin{semiverbatim}
     \scriptsize
\$ gcc -g -Wall --coverage goto-fail.c
\$ ./a.out
\$ ls
  a.out  goto-fail.c  goto-fail.gcda  goto-fail.gcno
\$ lcov --capture --directory project-dir --output-file coverage.info
\$ genhtml coverage.info --output-directory out
    \end{semiverbatim}
  \end{Example}
\end{frame}

\subsection{Kcov overview}
\begin{frame}{Kcov overview}
  \begin{itemize}
  \item Kcov started as a fork of Bcov by Thomas Neumann in 2010
  \item It is not related to the kernel Kcov (and predates it by many years)
  \item<2-> Can you guess why it's called kcov?
  \end{itemize}

  \note{
    Kcov started as a fork of bcov, which doesn't rely on compile-time instrumentation of binaries, but instead uses the DWARF debug information present as long as you compile with -g. It can also produce lcov-like output.

    I thought bcov was a great idea, but it was still somewhat cumbersome to use, separating collection and reporting. The codebase was a bit difficult for me to follow, so I forked it instead of improving on the original project. Today I would problably not have done it that way.

    Guess the name! The original idea I had was to use kernel kprobes, which allows setting breakpoints on kernel code, while still retaining the userspace functionality. K therfore stands for kernel.
  }
\end{frame}

\begin{frame}{Interactive Demo!}
  \note{
      \begin{itemize}
      \item Demo: Make sure /tmp/kcov is empty

      \item kcov /tmp/kcov projects/build/kcov/target/src/kcov

      \item Show result in browser

      \item Show how a single file looks, describe 1/3 etc

      \item Show file list again, note /usr/include etc

      \item Remove /tmp/kcov

      \item Run again with --include-pattern

      \item Run calc, show merged report
  \end{itemize}
  }
\end{frame}

\subsection{Main features of kcov}
\begin{frame}{Features}

  \begin{itemize}
  \end{itemize}

  \note{
    \begin{itemize}
      \item Run kcov with --include-pattern, note that --exclude-pattern and paths also exist

      \item Run kcov on another program (calc?), show that output is merged
    \end{itemize}
  }
\end{frame}

\section{How kcov works}

\subsection{Elves, dwarves and breakpoints}
\begin{frame}{Dwarf stabs Mach-O Elf}
  \note{The world of binary file formats and debug information is full of funny names. Stabs is an older format for debug information, but ELF, Mach-O and Dwarf is in active use on Unix systems.

    Kcov relies on Dwarf debug information to set a breakpoint on each executable line in the program. The debug information contains records of file:line to address mappings, which is exactly what kcov needs.
% Disassembly here
    
    Kcov executes the program in stopped state via ptrace, sets all breakpoints and then lets the program continue again. On each executed breakpoint, kcov marks the file:line pair as executed, removes the breakpoint and lets the program continue again. That's the basic way kcov works.
  }
  \begin{itemize}
    \item \textbf{elf\_version} must be called at program start!
  \end{itemize}
  % Disassembly
  % file:line -> addr
  % Cleared once it has been executed
\end{frame}

\subsection{Implementation quirks on different architectures}
\begin{frame}{kcov on Linux, FreeBSD and Mac OSX}
\end{frame}

\subsection{ELF/Dwarf implementation quirks}
\begin{frame}{Libelf}
  % file:line maps to an invalid address
\end{frame}

\section{Other kcov features}

\subsection{Integration with CI systems}
\begin{frame}{Integration}
  \begin{itemize}
  \item<1-> Kcov can produce output for multiple CI systems
  \item<1-> Uploading to Coveralls.io is built-in
  \item<2-> Uploading to Codecov.io is supported by the upstream site
  \end{itemize}
  \includegraphics<1>[height=6cm]{coveralls}
  \includegraphics<2>[height=6cm]{codecov}
\end{frame}

\subsection{Python/Bash}
\begin{frame}{Python}
\end{frame}

\subsection{System mode}
\begin{frame}{System mode}
\end{frame}

\end{document}

%Kcov - a single-step code coverage tool

%- Motivation

%  - What is code coverage?

%  - goto fail

% - Outline of the presentation


% - Setting: UNIX


% - Problems with gcov + lcov etc

%  - Multiple steps

%  - Loses data on program crash


%- Basic demo of kcov

%  - Explain how the output looks, 1/2 etc

%- History

%  - Bcov by Thomas Neumann

%  - Kernel kcov - not related

%- Some features

%  - What I use if for

%  - Demo with filtering, merging etc


%- How kcov works

%  - A bit about how gcov works

%  - Breakpoints

%  - Differences between OSX and Linux/FreeBSD

 % - Complain a bit about elf_version/libdwarf etc.


% - What about speed?
